name: CI Build & Deploy → Docker Hub

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write
  id-token: write
  actions: read

env:
  IMAGE_NAME: myapp-backend
  REGISTRY: docker.io

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout repository (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Set up QEMU (multi-arch build support)
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Set up Python (for small utilities if needed)
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Print short info
        run: |
          echo "Repository: $GITHUB_REPOSITORY"
          echo "Commit: $GITHUB_SHA"
          echo "Run number: $GITHUB_RUN_NUMBER"

      - name: Set image tag variables and compute image names
        id: set-vars
        run: |
          SHORT_SHA=${GITHUB_SHA::8}
          IMAGE_TAG="sha-${SHORT_SHA}-${GITHUB_RUN_NUMBER}"
          echo "SHORT_SHA=$SHORT_SHA" >> $GITHUB_ENV
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

          if [ -n "${{ secrets.IMAGE_NAME }}" ]; then
            IMAGE_NAME="${{ secrets.IMAGE_NAME }}"
          else
            IMAGE_NAME="${IMAGE_NAME}"
          fi
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV

          if [ -z "${{ secrets.DOCKERHUB_USERNAME }}" ]; then
            echo "ERROR: secrets.DOCKERHUB_USERNAME is not set"
            exit 1
          fi

          IMAGE_FULL="${REGISTRY}/${{ secrets.DOCKERHUB_USERNAME }}/${IMAGE_NAME}:${IMAGE_TAG}"
          IMAGE_LATEST="${REGISTRY}/${{ secrets.DOCKERHUB_USERNAME }}/${IMAGE_NAME}:latest"

          echo "IMAGE_FULL=$IMAGE_FULL" >> $GITHUB_ENV
          echo "IMAGE_LATEST=$IMAGE_LATEST" >> $GITHUB_ENV

          echo "Computed IMAGE_FULL=$IMAGE_FULL"

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Build and push image (tag and latest)
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_FULL }}
            ${{ env.IMAGE_LATEST }}

      - name: Verify pushed image (info only)
        run: |
          echo "Image pushed: ${IMAGE_FULL}"

      - name: Replace image reference in k8s manifest(s)
        run: |
          DEPLOYMENT_FILE="k8s/base/deployment.yaml"
          if [ ! -f "$DEPLOYMENT_FILE" ]; then
            echo "ERROR: $DEPLOYMENT_FILE not found. Adjust the path in the workflow."
            exit 1
          fi
          cp "$DEPLOYMENT_FILE" "${DEPLOYMENT_FILE}.bak"
          sed -E -i "0,/image:[[:space:]]*.*/s|image:[[:space:]]*.*|image: ${IMAGE_FULL}|" "$DEPLOYMENT_FILE"
          echo "Updated image in $DEPLOYMENT_FILE to ${IMAGE_FULL}"
          git --no-pager diff -- "$DEPLOYMENT_FILE" || true

      - name: Commit updated k8s manifest back to repo
        if: ${{ always() }}
        env:
          GIT_AUTHOR_NAME: "github-actions[bot]"
          GIT_AUTHOR_EMAIL: "github-actions[bot]@users.noreply.github.com"
        run: |
          git config user.name "${GIT_AUTHOR_NAME}"
          git config user.email "${GIT_AUTHOR_EMAIL}"
          git add k8s/base/deployment.yaml || true
          if git diff --cached --quiet; then
            echo "No manifest changes to commit."
          else
            git commit -m "ci: update k8s image to ${IMAGE_FULL} [skip ci]" || echo "commit failed"
            TARGET_BRANCH="${GITHUB_REF#refs/heads/}"
            git push origin HEAD:${TARGET_BRANCH} || {
              echo "Push failed — branch may be protected or permissions insufficient."
            }
            echo "Committed and attempted to push manifest update."
          fi

      - name: (Optional) Trigger Argo CD sync via API (if provided)
        if: ${{ secrets.ARGOCD_SERVER && secrets.ARGOCD_USERNAME && secrets.ARGOCD_PASSWORD }}
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_USERNAME: ${{ secrets.ARGOCD_USERNAME }}
          ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}
          APP_NAME: myapp-backend
        run: |
          apt-get update && apt-get install -y jq curl >/dev/null
          ARGO_TOKEN=$(curl -s -k -X POST "https://${ARGOCD_SERVER}/api/v1/session" \
            -H "Content-Type: application/json" \
            -d "{\"username\":\"${ARGOCD_USERNAME}\",\"password\":\"${ARGOCD_PASSWORD}\"}" \
            | jq -r .token)
          if [ -z "$ARGO_TOKEN" ] || [ "$ARGO_TOKEN" == "null" ]; then
            echo "Failed to obtain Argo CD token — check ARGOCD_SERVER and credentials"
            exit 1
          fi
          SYNC_OUT=$(curl -s -k -X POST "https://${ARGOCD_SERVER}/api/v1/applications/${APP_NAME}/sync" \
            -H "Authorization: Bearer ${ARGO_TOKEN}" -H "Content-Type: application/json" \
            -d '{"revision":"main","prune":true,"strategy":{ "hook":{}} }')
          echo "Argo CD sync response: $SYNC_OUT"

      - name: Clean up backups
        run: |
          rm -f k8s/base/deployment.yaml.bak || true

      - name: Done
        run: |
          echo "CI/CD job finished. Image: ${IMAGE_FULL}"
