name: CI Build & Deploy → Docker Hub

# Trigger on pushes to main (change branch if you want)
on:
  push:
    branches:
      - main

permissions:
  contents: write   # allow pushing changes back to repo
  id-token: write
  actions: read

env:
  # override if you prefer; you can also set IMAGE_NAME as a secret
  IMAGE_NAME: myapp-backend
  REGISTRY: docker.io

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout repository (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true  # allow pushing back using the GITHUB_TOKEN

      - name: Set up QEMU (multi-arch build support)
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Set up Python (for small utilities if needed)
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Print short info
        run: |
          echo "Repository: $GITHUB_REPOSITORY"
          echo "Commit: $GITHUB_SHA"
          echo "Run number: $GITHUB_RUN_NUMBER"

      - name: Set image tag variables
        id: set-vars
        run: |
          SHORT_SHA=${GITHUB_SHA::8}
          IMAGE_TAG="sha-${SHORT_SHA}-${GITHUB_RUN_NUMBER}"
          echo "SHORT_SHA=$SHORT_SHA" >> $GITHUB_ENV
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          # full image path (docker hub uses docker.io/username/name)
          if [ -n "${{ secrets.IMAGE_NAME }}" ]; then
            IMAGE_NAME="${{ secrets.IMAGE_NAME }}"
          else
            IMAGE_NAME="${{ env.IMAGE_NAME }}"
          fi
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
          IMAGE_FULL="${{ env.REGISTRY }}/${{ secrets.DOCKERHUB_USERNAME }}/$IMAGE_NAME:$IMAGE_TAG"
          echo "IMAGE_FULL=$IMAGE_FULL" >> $GITHUB_ENV
          echo "IMAGE_LATEST=${{ env.REGISTRY }}/${{ secrets.DOCKERHUB_USERNAME }}/$IMAGE_NAME:latest" >> $GITHUB_ENV
          echo "Computed IMAGE_FULL=$IMAGE_FULL"

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Build and push image (tag: ${{ env.IMAGE_TAG }} and :latest)
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_FULL }}
            ${{ env.IMAGE_LATEST }}
          # optionally use cache-from and cache-to to speed builds
          # cache-from: type=registry,ref=${{ env.IMAGE_LATEST }}
          # cache-to: type=inline

      - name: Verify pushed image (docker hub) (info only)
        run: |
          echo "Image pushed: $IMAGE_FULL"
          # You could add a call to Docker Hub API here to verify if desired (requires token)

      - name: Replace image reference in k8s manifest(s)
        run: |
          # Path to your deployment file(s)
          DEPLOYMENT_FILE="k8s/base/deployment.yaml"
          if [ ! -f "$DEPLOYMENT_FILE" ]; then
            echo "ERROR: $DEPLOYMENT_FILE not found. Adjust the path in the workflow."
            exit 1
          fi

          # Make a safe backup
          cp $DEPLOYMENT_FILE ${DEPLOYMENT_FILE}.bak

          # Replace the first 'image:' line with the new image. This is a simple approach
          # - works for typical single-container specs. If you have multiple containers,
          #   improve the sed pattern to match the container name.
          # Use delimiter '|' to avoid issues with slashes.
          NEW_IMAGE="$IMAGE_FULL"
          # Use a regex to replace image: <anything> to image: NEW_IMAGE
          sed -E -i "0,/image:[[:space:]]*.*/s|image:[[:space:]]*.*|image: $NEW_IMAGE|" $DEPLOYMENT_FILE

          echo "Updated image in $DEPLOYMENT_FILE to $NEW_IMAGE"
          echo "Changes (diff):"
          git --no-pager diff -- $DEPLOYMENT_FILE || true

      - name: Commit updated k8s manifest back to repo
        if: ${{ always() }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Stage and commit only if there are changes
          git add k8s/base/deployment.yaml
          if git diff --cached --quiet; then
            echo "No manifest changes to commit."
          else
            git commit -m "ci: update k8s image to $IMAGE_FULL [skip ci]" || echo "commit failed"
            # push back to the same branch (requires permissions and not-protected branch)
            git push origin HEAD:${GITHUB_REF#refs/heads/} || {
              echo "Push failed — branch may be protected or permissions insufficient."
              echo "If branch is protected, consider creating a PR instead of pushing directly."
              exit 0
            }
            echo "Committed and pushed manifest update."
          fi

      - name: (Optional) Trigger Argo CD sync via API (if provided)
        if: ${{ secrets.ARGOCD_SERVER && secrets.ARGOCD_USERNAME && secrets.ARGOCD_PASSWORD }}
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_USERNAME: ${{ secrets.ARGOCD_USERNAME }}
          ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}
          APP_NAME: myapp-backend   # change to your Argo CD Application name
        run: |
          echo "Logging into Argo CD and triggering a sync for application $APP_NAME"
          # Login and get token
          ARGO_TOKEN=$(curl -s -k -X POST "https://${ARGOCD_SERVER}/api/v1/session" \
            -H "Content-Type: application/json" \
            -d "{\"username\":\"${ARGOCD_USERNAME}\",\"password\":\"${ARGOCD_PASSWORD}\"}" \
            | jq -r .token)

          if [ -z "$ARGO_TOKEN" ] || [ "$ARGO_TOKEN" == "null" ]; then
            echo "Failed to obtain Argo CD token — check ARGOCD_SERVER and credentials"
            exit 1
          fi

          # Trigger sync
          SYNC_OUT=$(curl -s -k -X POST "https://${ARGOCD_SERVER}/api/v1/applications/${APP_NAME}/sync" \
            -H "Authorization: Bearer ${ARGO_TOKEN}" -H "Content-Type: application/json" \
            -d '{"revision":"main","prune":true,"strategy":{ "hook":{}} }')
          echo "Argo CD sync response: $SYNC_OUT"

      - name: Clean up backups
        run: |
          rm -f k8s/base/deployment.yaml.bak || true

      - name: Done
        run: echo "CI/CD job finished. Image: $IMAGE_FULL"
